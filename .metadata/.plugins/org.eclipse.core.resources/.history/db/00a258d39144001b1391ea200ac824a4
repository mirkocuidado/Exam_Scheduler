package main;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import generals.Exam;
import generals.Room;
import generals.Termin;

public class CSP_Algorithm {

	public static HashMap<Exam, List<Termin>> solution = new HashMap<>();

	public static List<Exam> exams = new ArrayList<>();

	public void initialDomain(List<Exam> exams, List<Room> rooms, String termins[], int duration) {
		for (Exam exam : exams) {
			List<Termin> listOfTermins = new ArrayList<>();
			for (int day = 1; day <= duration; ++day) {
				for (Room room : rooms) {
					if (room.getHasPCs() == 0 && exam.getIsOnPCs() == 1) {
						// then it is not in the domain!
					} else {
						for (String time : termins) {
							Termin termin = new Termin(room, time, day);
							listOfTermins.add(termin);
						}
					}
				}
			}
			exam.setDomain(listOfTermins);
			listOfTermins = null;
		}
	}

	public Exam getExamWithLeastPossibleOptions(List<Exam> exams) {
		for(Exam e: exams) {
			if(e.getNumOfPlaceTaken() != 0) {
				return e;
			}
		}
		
		int min = 100000;
		String examMinName = "";

		for (Exam e : exams) {
			if (e.getDomain().size() < min) {
				examMinName = e.getExamCodee();
				min = e.getDomain().size();
			}
		}

		for (Exam e : exams) {
			if (e.getExamCodee() == examMinName)
				return e;
		}

		return null;
	}

	class Sortbyroll implements Comparator<Termin> 
	{  
		public int compare(Termin a, Termin b) 
	    { 
	        return b.getRoom().getCapacity() - a.getRoom().getCapacity(); 
	    } 
	} 
	
	List<Termin> sortDomainForCurrentExam(Exam exam) {

		Collections.sort(exam.getDomain(), new Sortbyroll());

		return exam.getDomain();
	}

	public boolean isValidToAssign(List<Termin> listForThisExam, Termin termin, Exam exam) {
		if (listForThisExam.size() == 0)
			return true;
		
		for (Termin t : listForThisExam) {
			if (termin.getDay() != t.getDay() || termin.getRoom().getName().equals(t.getRoom().getName()) || !termin.getTime().equals(t.getTime()))
				return false;
		}
		
		return true;
	}

	public boolean algorithm(List<Exam> exams, int exams_size, int level, Exam exam_param) {	
		if (level == exams_size) {
			return true;
		}

		Exam exam = getExamWithLeastPossibleOptions(exams);
		if (exam == null) {
			return true;
		}
		
		if(exam_param!=null)
		System.out.println(level + ": " + exam.getExamCodee() + " needs " + exam.getNumberOfSignedStudents() + ", but has " + exam_param.getNumOfPlaceTaken());
		System.out.println(exam.getDomain().size() + " options left.");
		
		
		
		if(exam_param!=null)
			exam.setNumOfPlaceTaken(exam_param.getNumOfPlaceTaken());
		
		int flagFound = 0;
		for(Exam e: solution.keySet()) {
			if(e.equals(exam)) {
				flagFound = 1;
			}
		}
		if (flagFound == 0) {
			solution.put(exam, new ArrayList<>());
		}

		exam.setDomain(sortDomainForCurrentExam(exam));

		for (int i = 0; i < exam.getDomain().size(); i++) {
			Termin termin = exam.getDomain().get(i);

			List<Termin> solution_termins_for_exam = new ArrayList<>();
			
			for(Exam e: solution.keySet()) {
				if(e.equals(exam)) {
					solution_termins_for_exam = solution.get(exam);
				}
			}
			
			if (isValidToAssign(solution_termins_for_exam, termin, exam)) {

				/***** ADD TO LIST FOR TAKEN ONES AND ADD THE STUDENTS *****/
				for(Exam e: solution.keySet()) {
					if(e.equals(exam)) {
						solution.get(e).add(termin);
					}
				}
				exam.setNumOfPlaceTaken(termin.getRoom().getCapacity() + exam.getNumOfPlaceTaken());
				
				exam.setDayOfTrial(termin.getDay());
				
				List<Exam> copy_exams = new ArrayList<>();
				
				for(Exam e: exams) {
					
					if(e.getNumOfPlaceTaken() <= e.getNumberOfSignedStudents()) {
						Exam copy_exam = new Exam(e.getExamCodee(), e.getNumberOfSignedStudents(), e.getIsOnPCs(), e.getModules());
						
						if(e.equals(exam)) 
							copy_exam.setNumOfPlaceTaken(termin.getRoom().getCapacity() + copy_exam.getNumOfPlaceTaken());
						
						List<Termin> copy_termins = new ArrayList<>();
						for(Termin termin_iter: e.getDomain()) {
							Termin copy_termin = new Termin(termin_iter.getRoom(), termin_iter.getTime(), termin_iter.getDay());
							copy_termins.add(copy_termin);
						}
					
					
						boolean sameYearAndModule = exam.checkIfExamsAreSameYearAndSameModule(e);
						int dayOfRok = -1; 
						if(sameYearAndModule == true && exam.equals(e)==false) 
							dayOfRok = termin.getDay();
						
						Set<Termin> toBeRemoved = new HashSet<Termin>();
						
						for(int j=0; j<copy_termins.size(); ++j) {
							
							if(copy_termins.get(j).equals(termin) == true) {
								toBeRemoved.add(copy_termins.get(j));
							}
							
							if(exam.equals(e) == false) {
								if(dayOfRok == copy_termins.get(j).getDay()) {
									toBeRemoved.add(copy_termins.get(j));
								}
							}
							else {
								if(termin.getDay() == copy_termins.get(j).getDay() && termin.getRoom().equals(copy_termins.get(j).getRoom())) {
									toBeRemoved.add(copy_termins.get(j));
								}
							}
						}
						
						for(Termin t: toBeRemoved) {
							copy_termins.remove(t);
						}
						
						copy_exam.setDomain(copy_termins);
						
						copy_exams.add(copy_exam);
					}
				}
				
				
				int isDone = 0;
				if(exam.getNumberOfSignedStudents() <= exam.getNumOfPlaceTaken()) {
					copy_exams.remove(exam);
					isDone = 1;
				}
				else {
					isDone = 0;
				}
				
				if (algorithm(copy_exams, exams_size, level + isDone, (isDone==1)? null: exam) == true) {
					return true;
				} else {
					for(Exam e: solution.keySet()) {
						if(e.equals(exam)) {
							solution.get(e).remove(termin);
						}
					}
					
					
					for(Exam e: copy_exams) {
						e.getDomain().add(termin);
					}
				}
				
				
			}
		}
		
		
		if(exam.getNumOfPlaceTaken() >= exam.getNumberOfSignedStudents()) {
			return true;
		}
		else {
			System.exit(1);
			return false;
		}

	}				
				
				
				/***** MAKE A COPY OF EVERY EXAM *****/
				/*List<Exam> copy_exams = new ArrayList<>();

				
				 * for(Exam e: exams) { if(exam.equals(e) == false) {
				 * 
				 *//***** MAKE THE SAME EXAM AS THIS ONE WE ITERATE BY *****/
				/*
				 * Exam new_exam = new Exam(e.getExamCodee(), e.getNumberOfSignedStudents(),
				 * e.getIsOnPCs(), e.getModules());
				 * 
				 *//***** GET HIS DOMAIN SO YOU CAN EDIT IT *****/
				/*
				 * List<Termin> terminsForOldExam = e.getDomain();
				 * 
				 *//***** CHECK IF TWO EXAMS ARE FROM THE SAME YEAR AND SAME MODULE *****/
				/*
				 * boolean sameYearAndModule =
				 * exam.checkIfExamsAreSameYearAndSameModule(new_exam);
				 * 
				 * int dayOfRok = -1; if(sameYearAndModule == true) dayOfRok = termin.getDay();
				 *//***** IF FLAG IS TRUE REMOVE ALL DAYS FROM THE DOMAIN AS WELL *****/
				/*
				
				*//***** GO THROUGH ALL TERMINS *****/
				/*
				 * 
				 * // LIST OF TERMINS TO BE REMOVED! List<Termin> toBeRemoved = new
				 * ArrayList<>();
				 * 
				 * for(Termin terminOtherExam : terminsForOldExam) {
				 * if(termin.equals(terminOtherExam) == true) { toBeRemoved.add(termin);
				 *//***** REMOVE THE SAME TERMIN AS THIS ONE *****/
				/*
				 * }
				 * 
				 * if(dayOfRok == terminOtherExam.getDay()) {
				 *//***** IF DAY OF ROK IS SAME AS CURRENT *****//*
																	 * toBeRemoved.add(termin); } }
																	 * 
																	 * for(Termin terminForRemoving : toBeRemoved) {
																	 * terminsForOldExam.remove(terminForRemoving); }
																	 * 
																	 * copy_exams.add(new_exam); } }
																	 */

				//if (exam.getNumberOfSignedStudents() > exam.getNumOfPlaceTaken())
					//continue;

				/***** WARNING, ZABORAVICES! *****/

				/*****
				 * Ako nema dovoljno studenata i on ti daje kraj, treba da proveris i za novi
				 * dan !!!
				 *****/

				//solution.put(exam, listForThisExam);

				/*for (Termin zz : listForThisExam) {
					System.out.print(" " + zz.getDay() + " " + zz.getTime() + " " + zz.getRoom().getName());
				}
				System.out.println(" " + exam.getNumOfPlaceTaken() + "/" + exam.getNumberOfSignedStudents());*/

				/*if (algorithm(exams, level + 1) == true) {
					return true;
				} else {
					solution.remove(exam);
					listForThisExam.remove(listForThisExam.size() - 1);
				}*/


	/*
	 * private HashMap<Exam, List<Termin>> copyDomain(HashMap<Exam, List<Termin>>
	 * domains, List<Exam> exams, Exam exam, HashMap<Exam,Termin> solution, Termin
	 * terminTaken) { HashMap<Exam, List<Termin>> domainsCopy = new HashMap<>();
	 * for(Exam e: exams) { if(!exam.equals(e)) { List<Termin> list =
	 * domains.get(e); if(list != null) { List<Termin> terminsCopy = new
	 * ArrayList<>(); for(Termin t: list){ if(!t.equals(terminTaken)) {
	 * if(exam.checkIfExamsAreSameYearAndSameModule(e)) { Termin
	 * terminOfExamAlreadyAdded = solution.get(exam); if(terminOfExamAlreadyAdded !=
	 * null) { int dayOfExamAlreadyAdded = terminOfExamAlreadyAdded.getDay();
	 * if(t.getDay() != dayOfExamAlreadyAdded) terminsCopy.add(t); } } else
	 * terminsCopy.add(t); } } domainsCopy.put(e, terminsCopy); } } } return
	 * domainsCopy; }
	 */

}
